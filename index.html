<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Quiz Complet – Examen Blanc</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />

  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6; /* Tailwind gray-100 */
    }
    .quiz-page {
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }
    .quiz-page.active {
      display: block;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .question-block {
      margin-bottom: 1.5rem;
      padding: 1.25rem; /* p-5 */
      border: 1px solid #e5e7eb; /* Tailwind gray-200 */
      border-radius: 0.5rem; /* rounded-lg */
      background-color: white;
      box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
        0 1px 2px 0 rgba(0, 0, 0, 0.06); /* shadow-md */
    }
    .result {
      margin-top: 0.75rem; /* mt-3 */
      font-weight: 600; /* font-semibold */
      font-size: 0.875rem; /* text-sm */
    }
    .result.text-green-700 {
      color: #047857; /* Tailwind green-700 */
    }
    .result.text-red-700 {
      color: #b91c1c; /* Tailwind red-700 */
    }

    input[type='radio'] {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      width: 1.25em;
      height: 1.25em;
      border: 2px solid #6b7280; /* Tailwind gray-500 */
      border-radius: 50%;
      outline: none;
      cursor: pointer;
      margin-right: 0.5em;
      position: relative;
      top: 0.2em;
    }
    input[type='radio']:checked {
      border-color: #2563eb; /* Tailwind blue-600 */
      background-color: #2563eb; /* Tailwind blue-600 */
    }
    input[type='radio']:checked::before {
      content: '';
      display: block;
      width: 0.6em;
      height: 0.6em;
      background-color: white;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    label.flex {
      cursor: pointer;
    }

    #notificationArea {
      position: fixed;
      top: 1.25rem;
      right: 1.25rem;
      padding: 1rem;
      border-radius: 0.375rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
        0 4px 6px -2px rgba(0, 0, 0, 0.05);
      z-index: 100;
      display: none;
      color: white;
      font-weight: 500;
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.6);
      animation: fadeInModal 0.3s ease-out;
    }
    .modal-content {
      background-color: #fefefe;
      margin: 10% auto;
      padding: 2rem;
      border: 1px solid #888;
      width: 90%;
      max-width: 600px;
      border-radius: 0.75rem; /* rounded-xl */
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
        0 10px 10px -5px rgba(0, 0, 0, 0.04); /* shadow-2xl */
    }
    .modal-header {
      padding-bottom: 1rem;
      margin-bottom: 1rem;
      border-bottom: 1px solid #e5e7eb; /* Tailwind gray-200 */
    }
    .modal-body {
      max-height: 60vh;
      overflow-y: auto;
    }
    .close-button {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }
    .close-button:hover,
    .close-button:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }
    @keyframes fadeInModal {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Styles for category details in stats modal */
    .category-detail summary {
      cursor: pointer;
      padding: 0.5rem 0;
      font-weight: 600;
      color: #374151; /* Tailwind gray-700 */
      border-bottom: 1px solid #e5e7eb;
    }
    .category-detail summary:hover {
      color: #1f2937; /* Tailwind gray-900 */
    }
    .category-detail ul {
      list-style-type: disc;
      padding-left: 1.5rem;
      margin-top: 0.5rem;
    }
    .category-detail li {
      margin-bottom: 0.25rem;
      color: #4b5563; /* Tailwind gray-600 */
    }
  </style>
</head>

<body class="p-4 md:p-8">
  <div id="notificationArea"></div>

  <div class="container mx-auto max-w-3xl bg-white shadow-xl rounded-xl p-6 md:p-8">
    <header class="text-center mb-8 relative">
      <h1
        id="mainQuizTitle"
        class="text-4xl font-bold text-blue-700"
      >
        Examen Blanc Quiz Interactif
      </h1>
      <p id="mainQuizSubtitle" class="text-gray-600 mt-2">
        Testez vos connaissances avec ces 100 questions.
      </p>

      <button
        id="langToggleButton"
        onclick="toggleLanguage()"
        class="absolute top-0 right-0 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md text-sm transition-colors duration-150"
      >
        Switch to English
      </button>

      <div class="mt-4 flex justify-center space-x-4">
        <button
          id="testModeButton"
          onclick="switchMode('test')"
          class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-colors duration-150"
        >
          Mode Examen
        </button>
        <button
          id="learningModeButton"
          onclick="switchMode('learn')"
          class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-colors duration-150"
        >
          Mode Apprentissage
        </button>
      </div>

      <div id="shuffleControls" class="mt-4 flex items-center justify-center space-x-2">
        <label class="flex items-center space-x-2">
          <input type="checkbox" id="shuffleToggle" checked />
          <span id="shuffleLabel" class="text-gray-700">Ordre par défaut</span>
        </label>
        <button
          id="shuffleButton"
          class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-1 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed"
          disabled
        >
          Mélanger les questions
        </button>
      </div>
    </header>

    <div id="testModeContainer">
      <div id="page-0" class="quiz-page active">
        <h2
          id="pageTitle-0"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 1 – 10
        </h2>
      </div>
      <div id="page-1" class="quiz-page">
        <h2
          id="pageTitle-1"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 11 – 20
        </h2>
      </div>
      <div id="page-2" class="quiz-page">
        <h2
          id="pageTitle-2"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 21 – 30
        </h2>
      </div>
      <div id="page-3" class="quiz-page">
        <h2
          id="pageTitle-3"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 31 – 40
        </h2>
      </div>
      <div id="page-4" class="quiz-page">
        <h2
          id="pageTitle-4"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 41 – 50
        </h2>
      </div>
      <div id="page-5" class="quiz-page">
        <h2
          id="pageTitle-5"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 51 – 60
        </h2>
      </div>
      <div id="page-6" class="quiz-page">
        <h2
          id="pageTitle-6"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 61 – 70
        </h2>
      </div>
      <div id="page-7" class="quiz-page">
        <h2
          id="pageTitle-7"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 71 – 80
        </h2>
      </div>
      <div id="page-8" class="quiz-page">
        <h2
          id="pageTitle-8"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 81 – 90
        </h2>
      </div>
      <div id="page-9" class="quiz-page">
        <h2
          id="pageTitle-9"
          class="page-title text-2xl font-semibold mb-6 text-gray-800 border-b pb-2"
        >
          Questions 91 – 100
        </h2>
      </div>

      <footer class="mt-10 pt-6 border-t border-gray-300">
        <div class="navigation-controls flex justify-between items-center mb-4">
          <button
            id="prevButton"
            onclick="navigatePage(-1)"
            class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg shadow-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-150"
          >
            Précédent
          </button>
          <span id="pageIndicator" class="text-gray-700 font-medium text-lg"
            >Page 1 / 10</span
          >
          <button
            id="nextButton"
            onclick="navigatePage(1)"
            class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg shadow-md disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-150"
          >
            Suivant
          </button>
        </div>
        <div class="mt-6 space-y-3 md:space-y-0 md:flex md:space-x-3">
          <button
            id="viewResultsButton"
            onclick="showFinalResultsModal()"
            class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-6 rounded-lg w-full md:w-auto shadow-md transition-colors duration-150"
          >
            Voir les résultats finaux
          </button>
          <button
            id="resetAllButton"
            onclick="resetAllAnswers()"
            class="bg-red-600 hover:bg-red-700 text-white font-semibold py-3 px-6 rounded-lg w-full md:w-auto shadow-md transition-colors duration-150"
          >
            Réinitialiser toutes les réponses
          </button>
        </div>
      </footer>
    </div>

    <div id="learningModeContainer" style="display: none;">
      <div class="mt-8 pt-6 border-t border-gray-300">
        <h3 id="learningToolsTitle" class="text-2xl font-semibold mb-4 text-center text-gray-700">Outils d'Apprentissage</h3>
        <div class="space-y-3 md:space-y-0 md:flex md:space-x-3 md:justify-center">
          <button
            id="generatePracticeCardButton"
            onclick="generatePracticeCard()"
            class="bg-teal-500 hover:bg-teal-600 text-white font-semibold py-3 px-6 rounded-lg w-full md:w-auto shadow-md transition-colors duration-150"
          >
            Générer une Carte de Pratique (10 Q)
          </button>
          <button
            id="viewStatsButton"
            onclick="showPerformanceStatsModal()"
            class="bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-6 rounded-lg w-full md:w-auto shadow-md transition-colors duration-150"
          >
            Voir les Statistiques de Performance
          </button>
        </div>
      </div>

      <div id="practiceQuestionsDisplayArea" class="mt-8">
        </div>

      <div class="mt-6 text-center space-y-3">
          <button
            id="checkPracticeCardButton"
            onclick="checkPracticeCardAnswers()"
            class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md"
            style="display: none;"
          >
            Vérifier la Carte
          </button>
          <p id="practiceCardScoreText" class="text-lg font-semibold text-gray-800"></p>
          <button
            id="generateNewPracticeCardButton"
            onclick="generatePracticeCard()"
            class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md mt-4"
            style="display: none;"
          >
            Générer une Nouvelle Carte
          </button>
      </div>
    </div>

  </div>

  <div id="finalResultsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close-button" onclick="closeFinalResultsModal()">&times;</span>
        <h2 id="finalResultsTitle" class="text-2xl font-bold text-gray-800">
          Résultats Finaux
        </h2>
      </div>
      <div id="finalResultsBody" class="modal-body space-y-3">
        </div>
      <div class="mt-6 text-center">
        <p id="overallScoreText" class="text-xl font-bold text-blue-700"></p>
      </div>
    </div>
  </div>

  <div id="performanceStatsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close-button" onclick="closePerformanceStatsModal()">×</span>
        <h2 id="performanceStatsTitle" class="text-2xl font-bold text-gray-800">Statistiques de Performance</h2>
      </div>
      <div id="performanceStatsBody" class="modal-body space-y-2">
        </div>
    </div>
  </div>

  <div id="customConfirmationModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <span class="close-button" onclick="closeConfirmationModal()">&times;</span>
        <h2 class="text-2xl font-bold text-gray-800">Confirmation</h2>
      </div>
      <div id="confirmationModalBody" class="modal-body">
        <p class="text-gray-700"></p>
      </div>
      <div class="mt-6 text-center space-x-4">
        <button id="confirmYes" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md">Oui</button>
        <button id="confirmNo" class="bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md">Non</button>
      </div>
    </div>
  </div>

  <script src="./quizQuestions.js"></script>
  <script>
    // ––– Language and UI Strings –––
    let currentLanguage = 'fr';
    const uiStrings = {
      fr: {
        pageTitleDoc: 'Quiz Complet – Examen Blanc',
        mainQuizTitle: 'Examen Blanc Quiz Interactif',
        mainQuizSubtitle: 'Testez vos connaissances avec ces 100 questions.',
        langToggleButton: 'Switch to English',
        trueLabel: 'Vrai',
        falseLabel: 'Faux',
        correctFeedback: 'Correct !',
        incorrectFeedbackPrefix: 'Faux ! La bonne réponse était ',
        selectAnswerPrompt: 'Veuillez sélectionner une réponse.',
        checkAnswersButton: 'Vérifier les réponses',
        pageIndicatorPrefix: 'Page',
        prevButton: 'Précédent',
        nextButton: 'Suivant',
        resetButton: 'Réinitialiser toutes les réponses',
        viewResultsButton: 'Voir les résultats finaux',
        finalResultsTitle: 'Résultats Finaux',
        overallScoreLabel: 'Score Total',
        scoreForPageLabel: 'Score pour cette page',
        allAnswersResetMsg: 'Toutes les réponses ont été réinitialisées.',
        questionsLabel: 'Questions',
        noResultsYet:
          'Aucun résultat à afficher. Veuillez compléter des pages du quiz.',
        defaultLabel: 'Ordre par défaut',
        shuffleButton: 'Mélanger les questions',
        learningToolsTitle: "Outils d'Apprentissage",
        generatePracticeCardButton: "Générer une Carte de Pratique (10 Q)", // Changed to 10 Q
        viewStatsButton: "Voir les Statistiques de Performance",
        practiceCardTitle: "Carte de Pratique",
        checkPracticeCardButton: "Vérifier la Carte",
        performanceStatsTitle: "Statistiques de Performance",
        categoryUnseen: "Non vues",
        categoryNewLearning: "Nouvelles en apprentissage", // New category label
        categoryLearning: "En apprentissage", // This will now be a general label, sub-categories will be used internally
        categoryLearningBad: "En apprentissage (difficile)", // New label
        categoryLearningNormal: "En apprentissage (normal)", // New label
        categoryLearningGood: "En apprentissage (facile)", // New label
        categoryMastered: "Maîtrisées",
        categoryProblematic: "Problématiques",
        questionsInCategory: "questions dans cette catégorie",
        totalCorrect: "Total Correct",
        totalIncorrect: "Total Incorrect",
        performanceDataReset: "Données de performance réinitialisées.",
        confirmResetPerformance: "Êtes-vous sûr de vouloir réinitialiser toutes les données de performance des questions ? Cette action est irréversible.",
        testModeButton: "Mode Examen",
        learningModeButton: "Mode Apprentissage",
        generateNewPracticeCardButton: "Générer une Nouvelle Carte",
        noQuestionsAvailableForPractice: "Pas assez de questions disponibles pour générer une carte de pratique. Essayez de répondre à plus de questions en mode examen ou réinitialisez vos données."
      },
      en: {
        pageTitleDoc: 'Complete Quiz – Mock Exam',
        mainQuizTitle: 'Interactive Mock Exam Quiz',
        mainQuizSubtitle: 'Test your knowledge with these 100 questions.',
        langToggleButton: 'Passer en Français',
        trueLabel: 'True',
        falseLabel: 'False',
        correctFeedback: 'Correct!',
        incorrectFeedbackPrefix: 'Wrong! The correct answer was ',
        selectAnswerPrompt: 'Please select an answer.',
        checkAnswersButton: 'Check Answers',
        pageIndicatorPrefix: 'Page',
        prevButton: 'Previous',
        nextButton: 'Next',
        resetButton: 'Reset All Answers',
        viewResultsButton: 'View Final Results',
        finalResultsTitle: 'Final Results',
        overallScoreLabel: 'Total Score',
        scoreForPageLabel: 'Score for this page',
        allAnswersResetMsg: 'All answers have been reset.',
        questionsLabel: 'Questions',
        noResultsYet:
          'No results to display yet. Please complete some quiz pages.',
        defaultLabel: 'Default order',
        shuffleButton: 'Shuffle Questions',
        learningToolsTitle: "Learning Tools",
        generatePracticeCardButton: "Generate Practice Card (10 Q)", // Changed to 10 Q
        viewStatsButton: "View Performance Stats",
        practiceCardTitle: "Practice Card",
        checkPracticeCardButton: "Check Card Answers",
        performanceStatsTitle: "Performance Statistics",
        categoryUnseen: "Unseen",
        categoryNewLearning: "New Learning", // New category label
        categoryLearning: "Learning", // General label
        categoryLearningBad: "Learning (difficult)", // New label
        categoryLearningNormal: "Learning (normal)", // New label
        categoryLearningGood: "Learning (easy)", // New label
        categoryMastered: "Mastered",
        categoryProblematic: "Problematic",
        questionsInCategory: "questions in this category",
        totalCorrect: "Total Correct",
        totalIncorrect: "Total Incorrect",
        performanceDataReset: "Performance data has been reset.",
        confirmResetPerformance: "Are you sure you want to reset all question performance data? This action cannot be undone.",
        testModeButton: "Test Mode",
        learningModeButton: "Learning Mode",
        generateNewPracticeCardButton: "Generate New Card",
        noQuestionsAvailableForPractice: "Not enough questions available to generate a practice card. Try answering more questions in test mode or reset your data."
      }
    };

    // The allQuizData array is now loaded from quizQuestions.js
    // It is globally available because quizQuestions.js is loaded before this script.


    // ––– Global Variables & Constants –––
    let quizOrder = Array.from({ length: allQuizData.length }, (_, i) => i);
    const originalOrder = Array.from(quizOrder); // [0, 1, 2, …, 99]
    let currentPageIndex = 0;
    const questionsPerPage = 10;
    const numPages = Math.ceil(allQuizData.length / questionsPerPage);
    const pageElements = [];
    let pageScores = Array(numPages)
      .fill(null)
      .map(() => ({ score: 0, totalQuestions: 0, attempted: false }));

    // Global variable to hold performance data for each question
    let performanceData = {};
    // { qNum: { qNumOriginal: 'actualQNum', correctAttempts: 0, incorrectAttempts: 0, category: 'unseen', history: [], lastSeenInQuiz: 0 } }
    // Categories: 'unseen', 'new-learning', 'learning-bad', 'learning-normal', 'learning-good', 'mastered', 'problematic'

    let currentPracticeCardQuestions = []; // To store questions for the current practice card
    const PRACTICE_CARD_SIZE = 10; // Changed to 10 questions per practice card
    let currentMode = 'test'; // 'test' or 'learn'
    let quizCounter = 0; // Tracks how many practice cards have been generated

    // ––– Initialization on DOMContentLoaded –––
    document.addEventListener('DOMContentLoaded', () => {
      // 1) Collect page containers
      for (let i = 0; i < numPages; i++) {
        pageElements.push(document.getElementById(`page-${i}`));
      }

      // Load performance data
      loadPerformanceData();

      // 2) Set up UI text & button labels in the current language
      updateAllUIText();

      // 3) Shuffle checkbox & button
      const shuffleToggle = document.getElementById('shuffleToggle');
      const shuffleButton = document.getElementById('shuffleButton');

      shuffleToggle.addEventListener('change', () => {
        if (shuffleToggle.checked) {
          // Restore default order
          quizOrder = Array.from(originalOrder);
          resetAllAnswers(); // This will now also reset performance data
          renderCurrentPageQuestionsAndFeedback();
          shuffleButton.disabled = true;
        } else {
          // Enable shuffle
          shuffleButton.disabled = false;
        }
      });

      shuffleButton.addEventListener('click', () => {
        // Fisher–Yates shuffle
        for (let i = quizOrder.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [quizOrder[i], quizOrder[i]] = [quizOrder[j], quizOrder[i]]; // Fix: should be [quizOrder[i], quizOrder[j]] = [quizOrder[j], quizOrder[i]];
        }
        resetAllAnswers(); // This will now also reset performance data
        renderCurrentPageQuestionsAndFeedback();
      });

      // 4) Initially render page 0 and set initial mode
      switchMode(currentMode); // Set initial display mode
      updateNavigation();
      renderCurrentPageQuestionsAndFeedback();
    });

    // ––– Language Switching –––
    function toggleLanguage() {
      currentLanguage = currentLanguage === 'fr' ? 'en' : 'fr';
      updateAllUIText();
      renderCurrentPageQuestionsAndFeedback(); // Re-render questions with new language
      // Re-render stats modal if open
      if (document.getElementById('performanceStatsModal').style.display === 'block') {
        showPerformanceStatsModal();
      }
      // If in learning mode, re-render practice card if questions are already displayed
      if (currentMode === 'learn' && currentPracticeCardQuestions.length > 0) {
          renderPracticeCardQuestions(currentPracticeCardQuestions);
      }
    }

    function updateAllUIText() {
      const s = uiStrings[currentLanguage];
      document.title = s.pageTitleDoc;
      document.getElementById('mainQuizTitle').textContent = s.mainQuizTitle;
      document.getElementById('mainQuizSubtitle').textContent =
        s.mainQuizSubtitle;
      document.getElementById('langToggleButton').textContent =
        s.langToggleButton;

      // Mode buttons
      document.getElementById('testModeButton').textContent = s.testModeButton;
      document.getElementById('learningModeButton').textContent = s.learningModeButton;


      // Shuffle labels
      document.getElementById('shuffleLabel').textContent = s.defaultLabel;
      document.getElementById('shuffleButton').textContent =
        s.shuffleButton;

      // Nav button labels
      document.getElementById('prevButton').textContent = s.prevButton;
      document.getElementById('nextButton').textContent = s.nextButton;
      document.getElementById('resetAllButton').textContent = s.resetButton;
      document.getElementById('viewResultsButton').textContent =
        s.viewResultsButton;
      document.getElementById('finalResultsTitle').textContent =
        s.finalResultsTitle;

      // New UI text updates for learning mode
      document.getElementById('learningToolsTitle').textContent = s.learningToolsTitle;
      document.getElementById('generatePracticeCardButton').textContent = s.generatePracticeCardButton;
      document.getElementById('viewStatsButton').textContent = s.viewStatsButton;
      if (document.getElementById('checkPracticeCardButton')) { // Check if element exists before updating
        document.getElementById('checkPracticeCardButton').textContent = s.checkPracticeCardButton;
      }
      if (document.getElementById('generateNewPracticeCardButton')) { // Check if element exists before updating
        document.getElementById('generateNewPracticeCardButton').textContent = s.generateNewPracticeCardButton;
      }
      document.getElementById('performanceStatsTitle').textContent = s.performanceStatsTitle;


      // Page headings
      pageElements.forEach((page, idx) => {
        const titleEl = document.getElementById(`pageTitle-${idx}`);
        if (!titleEl) return;
        const startQ = idx * questionsPerPage + 1;
        const endQ = Math.min((idx + 1) * questionsPerPage, allQuizData.length);
        titleEl.textContent = `${s.questionsLabel} ${startQ} – ${endQ}`;
      });

      updateNavigation();
    }

    // ––– Mode Switching –––
    function switchMode(mode) {
      currentMode = mode;
      const testContainer = document.getElementById('testModeContainer');
      const learnContainer = document.getElementById('learningModeContainer');
      const shuffleControls = document.getElementById('shuffleControls');

      if (mode === 'test') {
        testContainer.style.display = 'block';
        learnContainer.style.display = 'none';
        shuffleControls.style.display = 'flex'; // Show shuffle controls in test mode
        updateNavigation(); // Ensure test mode pagination is updated
        renderCurrentPageQuestionsAndFeedback(); // Ensure questions are rendered
      } else { // 'learn' mode
        testContainer.style.display = 'none';
        learnContainer.style.display = 'block';
        shuffleControls.style.display = 'none'; // Hide shuffle controls in learning mode
        // Clear any previous practice questions when switching to learn mode
        document.getElementById('practiceQuestionsDisplayArea').innerHTML = '';
        document.getElementById('checkPracticeCardButton').style.display = 'none';
        document.getElementById('practiceCardScoreText').textContent = '';
        document.getElementById('generateNewPracticeCardButton').style.display = 'none';
      }
    }


    // ––– Render Current Page (Questions + Buttons) –––
    function renderCurrentPageQuestionsAndFeedback() {
      const pageEl = pageElements[currentPageIndex];
      if (!pageEl) return;

      // 1) Keep the <h2> heading intact
      const heading = pageEl.querySelector('.page-title');
      const headingHTML = heading ? heading.outerHTML : '';

      // 2) Clear entire page, then re-insert heading
      pageEl.innerHTML = headingHTML;

      // 3) Append the 10 question-blocks for this page
      const startIdx = currentPageIndex * questionsPerPage;
      const endIdx = Math.min(startIdx + questionsPerPage, allQuizData.length);

      for (let i = startIdx; i < endIdx; i++) {
        const dataIdx = quizOrder[i]; // index into allQuizData
        const qData = allQuizData[dataIdx];
        pageEl.appendChild(createQuestionElement(qData, 'q')); // Pass 'q' prefix for test mode
      }

      // 4) Append “Check Answers” button + score placeholder
      addCheckButtonAndScoreToPage(currentPageIndex);

      // 5) If page was already attempted, re-run checkAnswers (calculateScore = false)
      if (
        pageScores[currentPageIndex] &&
        pageScores[currentPageIndex].attempted
      ) {
        checkAnswersForPage(
          currentPageIndex,
          startIdx + 1,
          endIdx,
          false
        );
      }
    }

    // ––– Create a Single Question Block (Bilingual) –––
    // Added a 'prefix' argument to differentiate radio button names between test and practice modes
    function createQuestionElement(qData, prefix = 'q', displayIndex = null) {
      const s = uiStrings[currentLanguage];
      const div = document.createElement('div');
      div.className = 'question-block';
      const actualDisplayIndex = displayIndex !== null ? displayIndex : qData.qNum; // Use provided index or qNum

      div.innerHTML = `
        <p class="text-gray-800 text-base"><b>${actualDisplayIndex}.</b> ${
        qData.text[currentLanguage]
      }</p>
        <div class="mt-3 space-y-2">
          <label class="flex items-center p-2 rounded-md hover:bg-gray-50 transition-colors duration-150">
            <input type="radio" name="${prefix}${qData.qNum}" value="true">
            <span class="ml-3 text-gray-700 true-label">${s.trueLabel}</span>
          </label>
          <label class="flex items-center p-2 rounded-md hover:bg-gray-50 transition-colors duration-150">
            <input type="radio" name="${prefix}${qData.qNum}" value="false">
            <span class="ml-3 text-gray-700 false-label">${s.falseLabel}</span>
          </label>
        </div>
        <p id="${prefix}${qData.qNum}-result" class="result mt-2"></p>
      `;

      // Add event listeners for immediate feedback
      const radioButtons = div.querySelectorAll(`input[name="${prefix}${qData.qNum}"]`);
      radioButtons.forEach(radio => {
          radio.addEventListener('change', (event) => {
              const selectedVal = event.target.value;
              // Clear previous feedback immediately
              const resultEl = document.getElementById(`${prefix}${qData.qNum}-result`);
              if (resultEl) {
                  resultEl.textContent = '';
                  resultEl.className = 'result mt-2';
              }
              // Provide feedback after a short delay
              setTimeout(() => {
                  processSingleQuestionAnswer(qData, selectedVal, prefix);
              }, 330); // 0.75 seconds delay
          });
      });

      return div;
    }

    // ––– Add “Check Answers” Button & Score Placeholder to Page –––
    function addCheckButtonAndScoreToPage(pageIdx) {
      const s = uiStrings[currentLanguage];
      const pageEl = pageElements[pageIdx];
      if (!pageEl) return;

      // Remove any existing check button to prevent duplicates
      const existingBtn = pageEl.querySelector('.check-answers-btn');
      if (existingBtn) {
          existingBtn.remove();
      }
      const existingScoreP = pageEl.querySelector('.page-score-display');
      if (existingScoreP) {
          existingScoreP.remove();
      }

      const btn = document.createElement('button');
      btn.onclick = () => checkAnswersForPage(pageIdx, true); // Simplified call
      btn.className =
        'check-answers-btn bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg w-full mt-6 shadow-md transition-colors duration-150';
      btn.textContent = `${s.checkAnswersButton} (${s.pageIndicatorPrefix} ${
        pageIdx + 1
      })`;
      pageEl.appendChild(btn);

      const scoreP = document.createElement('p');
      scoreP.id = `score-page-${pageIdx}`;
      scoreP.className =
        'page-score-display text-center font-semibold text-lg mt-4 text-gray-800';
      pageEl.appendChild(scoreP);
    }

    // ––– Update Pagination Controls –––
    function updateNavigation() {
      const s = uiStrings[currentLanguage];
      pageElements.forEach((page, idx) => {
        if (!page) return;
        if (idx === currentPageIndex) {
          page.style.display = 'block';
          page.classList.add('active');
        } else {
          page.style.display = 'none';
          page.classList.remove('active');
        }
      });
      document.getElementById(
        'pageIndicator'
      ).textContent = `${s.pageIndicatorPrefix} ${currentPageIndex + 1} / ${numPages}`;
      document.getElementById('prevButton').disabled =
        currentPageIndex === 0;
      document.getElementById('nextButton').disabled =
        currentPageIndex === numPages - 1;

      // Scroll container into view
      const container = document.querySelector('.container.mx-auto');
      if (container) {
        container.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function navigatePage(dir) {
      const newIdx = currentPageIndex + dir;
      if (newIdx >= 0 && newIdx < numPages) {
        currentPageIndex = newIdx;
        updateNavigation();
        renderCurrentPageQuestionsAndFeedback();
      }
    }

    // ––– Process a Single Question's Answer and Update Performance Data –––
    function processSingleQuestionAnswer(qData, selectedVal, prefix) {
        const s = uiStrings[currentLanguage];
        const resultEl = document.getElementById(`${prefix}${qData.qNum}-result`);

        if (!resultEl) return;

        const wasCorrect = selectedVal === qData.answer;

        if (wasCorrect) {
            resultEl.textContent = s.correctFeedback;
            resultEl.className = "result text-green-700";
        } else {
            const correctText = (qData.answer === "true") ? s.trueLabel : s.falseLabel;
            resultEl.textContent = `${s.incorrectFeedbackPrefix}${correctText}.`;
            resultEl.className = "result text-red-700";
        }

        // Update performance data for this specific question
        const qNumForPerf = qData.qNum;
        if (!performanceData[qNumForPerf]) {
            performanceData[qNumForPerf] = { qNumOriginal: qNumForPerf, correctAttempts: 0, incorrectAttempts: 0, category: 'unseen', history: [], lastSeenInQuiz: 0 };
        }
        const questionPerf = performanceData[qNumForPerf];

        if (wasCorrect) {
            questionPerf.correctAttempts++;
        } else {
            questionPerf.incorrectAttempts++;
        }
        questionPerf.history.push({ timestamp: Date.now(), correct: wasCorrect });
        if (questionPerf.history.length > 10) questionPerf.history.shift(); // Keep last 10 history items

        updateQuestionCategory(qNumForPerf);
        savePerformanceData(); // Save after each question update
    }


    // ––– Check Answers for One Page (Test Mode) –––
    function checkAnswersForPage(pageIdx, calculateScore = true) {
      const s = uiStrings[currentLanguage];
      let score = 0;

      const startIdx = pageIdx * questionsPerPage;
      const endIdx = Math.min(startIdx + questionsPerPage, allQuizData.length);
      const questionsOnThisPage = endIdx - startIdx;

      if (calculateScore) {
        pageScores[pageIdx] = {
          score: 0,
          totalQuestions: questionsOnThisPage,
          attempted: true
        };
      }

      for (let i = startIdx; i < endIdx; i++) {
        const dataIdx = quizOrder[i];
        const qData   = allQuizData[dataIdx];
        const qNumber = qData.qNum;

        const radios   = document.getElementsByName(`q${qNumber}`);
        let selectedVal = null;
        radios.forEach(rb => { if (rb.checked) selectedVal = rb.value; });

        // If a selection was made, process it. Immediate feedback already handles performance data update.
        if (selectedVal !== null) {
            // Recalculate score for the page based on the current state of performanceData
            // This is important because individual question answers are now processed immediately
            const questionPerf = performanceData[qNumber];
            if (questionPerf && questionPerf.history.length > 0 && questionPerf.history[questionPerf.history.length - 1].correct) {
                score++;
            }
        }
      }

      if (calculateScore && pageScores[pageIdx]) {
        pageScores[pageIdx].score = score;
      }

      const scoreEl = document.getElementById(`score-page-${pageIdx}`);
      if (scoreEl && pageScores[pageIdx]) {
        scoreEl.textContent =
          `${s.scoreForPageLabel}: ${pageScores[pageIdx].score} / ${pageScores[pageIdx].totalQuestions}`;
      }
      // No need to call savePerformanceData here as it's called by processSingleQuestionAnswer
    }

    // ––– Reset All Answers & Scores –––
    function resetAllAnswers() {
      const s = uiStrings[currentLanguage];
      // Use a custom modal for confirmation instead of alert/confirm
      showConfirmationModal(s.confirmResetPerformance, () => {
        allQuizData.forEach((qData) => {
          // Reset test mode radio buttons and feedback
          const radios = document.getElementsByName(`q${qData.qNum}`);
          radios.forEach((rb) => (rb.checked = false));
          const resEl = document.getElementById(`q${qData.qNum}-result`);
          if (resEl) {
            resEl.textContent = '';
            resEl.className = 'result mt-2';
          }
          // Reset practice mode radio buttons and feedback (if any are rendered)
          const pqRadios = document.getElementsByName(`pq${qData.qNum}`);
          pqRadios.forEach((rb) => (rb.checked = false));
          const pqResEl = document.getElementById(`pq${qData.qNum}-result`);
          if (pqResEl) {
            pqResEl.textContent = '';
            pqResEl.className = 'result mt-2';
          }
        });
        pageScores = Array(numPages)
          .fill(null)
          .map(() => ({ score: 0, totalQuestions: 0, attempted: false }));
        for (let i = 0; i < numPages; i++) {
          const scEl = document.getElementById(`score-page-${i}`);
          if (scEl) scEl.textContent = '';
        }

        // Reset performance data
        performanceData = {};
        allQuizData.forEach(qData => {
          performanceData[qData.qNum] = {
            qNumOriginal: qData.qNum,
            correctAttempts: 0,
            incorrectAttempts: 0,
            category: 'unseen',
            history: [],
            lastSeenInQuiz: 0 // Reset last seen counter
          };
        });
        quizCounter = 0; // Reset quiz counter
        savePerformanceData();
        showNotification(s.performanceDataReset, 'success');
        renderCurrentPageQuestionsAndFeedback(); // Re-render current page to clear feedback
      });
    }

    // Custom Confirmation Modal (instead of window.confirm)
    let confirmationModalCallback = null;
    function showConfirmationModal(message, callback) {
        const modal = document.getElementById('customConfirmationModal');
        const modalBody = document.getElementById('confirmationModalBody').querySelector('p');
        modalBody.textContent = message;

        modal.style.display = 'block';

        confirmationModalCallback = callback;

        document.getElementById('confirmYes').onclick = () => {
            if (confirmationModalCallback) confirmationModalCallback();
            closeConfirmationModal();
        };
        document.getElementById('confirmNo').onclick = () => {
            closeConfirmationModal();
        };
    }

    function closeConfirmationModal() {
        document.getElementById('customConfirmationModal').style.display = 'none';
        confirmationModalCallback = null;
    }


    // ––– Show Notification Toast –––
    function showNotification(message, type = 'info') {
      const note = document.getElementById('notificationArea');
      if (!note) return;
      note.textContent = message;
      let bg = 'bg-blue-600';
      if (type === 'success') bg = 'bg-green-600';
      if (type === 'error') bg = 'bg-red-600';
      note.className = `fixed top-5 right-5 p-4 rounded-md shadow-lg z-100 text-white font-medium ${bg}`;
      note.style.display = 'block';
      setTimeout(() => {
        note.style.display = 'none';
      }, 3000);
    }

    // ––– Show Final Results Modal –––
    function showFinalResultsModal() {
      const s = uiStrings[currentLanguage];
      const body = document.getElementById('finalResultsBody');
      body.innerHTML = '';
      let overallAchieved = 0;
      let overallTotal = 0;
      let anyAttempted = false;

      pageScores.forEach((pageScore, idx) => {
        if (pageScore && pageScore.attempted) {
          anyAttempted = true;
          const p = document.createElement('p');
          p.className = 'text-gray-700';
          p.textContent = `${s.pageIndicatorPrefix} ${
            idx + 1
          }: ${pageScore.score} / ${pageScore.totalQuestions}`;
          body.appendChild(p);
          overallAchieved += pageScore.score;
          overallTotal += pageScore.totalQuestions;
        }
      });

      if (!anyAttempted) {
        body.textContent = s.noResultsYet;
        document.getElementById('overallScoreText').textContent = '';
      } else {
        document.getElementById(
          'overallScoreText'
        ).textContent = `${s.overallScoreLabel}: ${overallAchieved} / ${overallTotal}`;
      }
      document.getElementById('finalResultsModal').style.display = 'block';
    }
    function closeFinalResultsModal() {
      document.getElementById('finalResultsModal').style.display = 'none';
    }

    // ––– START OF NEW PERFORMANCE TRACKING AND PRACTICE CARD LOGIC –––

    // Function to initialize or load performance data from localStorage
    function loadPerformanceData() {
      const savedData = localStorage.getItem('quizPerformanceData_v1');
      if (savedData) {
        performanceData = JSON.parse(savedData);
        // Load quizCounter as well
        const savedQuizCounter = localStorage.getItem('quizCounter_v1');
        if (savedQuizCounter) {
            quizCounter = parseInt(savedQuizCounter, 10);
        }
        // Ensure all questions from allQuizData are in performanceData and have new properties
        allQuizData.forEach(qData => {
          if (!performanceData[qData.qNum]) {
            performanceData[qData.qNum] = {
              qNumOriginal: qData.qNum,
              correctAttempts: 0,
              incorrectAttempts: 0,
              category: 'unseen', // Default to unseen
              history: [],
              lastSeenInQuiz: 0 // Initialize for new property
            };
          } else {
              // Ensure existing data has lastSeenInQuiz, default to 0 if missing
              if (performanceData[qData.qNum].lastSeenInQuiz === undefined) {
                  performanceData[qData.qNum].lastSeenInQuiz = 0;
              }
              // Re-evaluate category on load in case logic changed
              updateQuestionCategory(qData.qNum);
          }
        });
      } else {
        // Initialize for all questions if no data found
        allQuizData.forEach(qData => {
          performanceData[qData.qNum] = {
            qNumOriginal: qData.qNum,
            correctAttempts: 0,
            incorrectAttempts: 0,
            category: 'unseen',
            history: [],
            lastSeenInQuiz: 0
          };
        });
        quizCounter = 0;
      }
      console.log("Performance data loaded/initialized:", performanceData);
      console.log("Quiz Counter loaded:", quizCounter);
    }

    // Function to save performance data to localStorage
    function savePerformanceData() {
      localStorage.setItem('quizPerformanceData_v1', JSON.stringify(performanceData));
      localStorage.setItem('quizCounter_v1', quizCounter.toString());
      console.log("Performance data saved.");
      console.log("Quiz Counter saved:", quizCounter);
    }

    // Function to update a question's category based on its performance
    function updateQuestionCategory(qNumKey) {
      const stats = performanceData[qNumKey];
      if (!stats) return;

      const totalAttempts = stats.correctAttempts + stats.incorrectAttempts;
      const historyLength = stats.history.length;

      // Get last 3 attempts for problematic/mastered and last 2 for learning-good/bad
      const recentHistory = stats.history.slice(-3);
      const recentCorrectCount = recentHistory.filter(h => h.correct).length;
      const recentIncorrectCount = recentHistory.length - recentCorrectCount;

      const lastTwoAttempts = stats.history.slice(-2);
      const lastIsCorrect = lastTwoAttempts.length > 0 ? lastTwoAttempts[lastTwoAttempts.length - 1].correct : null;
      const secondLastIsCorrect = lastTwoAttempts.length > 1 ? lastTwoAttempts[lastTwoAttempts.length - 2].correct : null;

      // 1. Catégorie 'unseen' (Non vues)
      if (totalAttempts === 0) {
        stats.category = 'unseen';
        return;
      }

      // 2. Catégorie 'new-learning' (Nouvelles en apprentissage)
      // This ensures a question always passes through new-learning first (after unseen).
      if (totalAttempts === 1) {
        stats.category = 'new-learning';
        return;
      }

      // 3. Catégorie 'problematic' (Problématiques)
      // At least 3 attempts and ALL of the last 3 attempts were incorrect
      if (historyLength >= 3 && recentIncorrectCount === 3) {
        stats.category = 'problematic';
        return;
      }

      // 4. Catégorie 'mastered' (Maîtrisées)
      // Strict conditions for true mastery: at least 5 correct, >=90% overall ratio, AND last 3 attempts are correct
      const correctRatio = totalAttempts > 0 ? stats.correctAttempts / totalAttempts : 0;
      if (
        stats.correctAttempts >= 5 &&
        correctRatio >= 0.9 &&
        recentCorrectCount === 3 &&
        historyLength >= 3
      ) {
        stats.category = 'mastered';
        return;
      }

      // 5. Learning Sub-categories (Only if not unseen, new-learning, problematic, or mastered)
      if (historyLength >= 2) {
        // Learning-bad: Last two attempts were incorrect
        if (lastIsCorrect === false && secondLastIsCorrect === false) {
          stats.category = 'learning-bad';
          return;
        }
        // Learning-good: Last two attempts were correct
        else if (lastIsCorrect === true && secondLastIsCorrect === true) {
          stats.category = 'learning-good';
          return;
        }
      }

      // 6. Learning-normal (Default for questions that don't fit previous specific criteria)
      stats.category = 'learning-normal';
    }

    // --- Practice Card Functions ---
    function generatePracticeCard() {
      quizCounter++; // Increment quiz counter for tracking last seen questions
      const s = uiStrings[currentLanguage];
      currentPracticeCardQuestions = [];

      // Define all categories, including the new learning sub-categories
      const allCategories = ['problematic', 'learning-bad', 'learning-normal', 'learning-good', 'new-learning', 'unseen', 'mastered'];
      const candidates = {};
      allCategories.forEach(cat => candidates[cat] = []);

      // Populate candidates based on their category
      allQuizData.forEach(qData => {
        const perf = performanceData[qData.qNum] || { category: 'unseen' };
        if (allCategories.includes(perf.category)) {
          candidates[perf.category].push(qData);
        } else {
          // Fallback for any unexpected categories (should be rare with updated logic)
          candidates['learning-normal'].push(qData);
        }
      });

      // Shuffle each category list to ensure randomness within categories
      for (const category in candidates) {
        candidates[category].sort(() => 0.5 - Math.random());
      }

      let count = 0;
      const PRACTICE_CARD_SIZE = 10;
      const BOOST_INTERVAL = 3; // Every 3 quizzes, boost unseen/new-learning
      const applyBoost = (quizCounter % BOOST_INTERVAL === 0);

      // Define target counts for each category for a 10-question card
      // These are flexible targets, actual counts may vary based on availability
      const targetCounts = {
          problematic: 3,
          'learning-bad': 2,
          'learning-normal': 1,
          'learning-good': 1,
          'new-learning': applyBoost ? 2 : 1, // Boosted
          unseen: applyBoost ? 2 : 1, // Boosted
          mastered: 0 // Will be added via resurfacing logic
      };

      const minMasteredResurfaceInterval = 15; // How many quizzes before a mastered question can resurface

      // Priority order for filling the card (from most difficult/urgent to easiest/less urgent)
      const priorityOrder = ['problematic', 'learning-bad', 'new-learning', 'unseen', 'learning-normal', 'learning-good'];

      // 1. Fill based on target counts and priority
      for (const category of priorityOrder) {
          let needed = targetCounts[category] || 0; // Get target count, default to 0 if not defined
          while (needed > 0 && candidates[category].length > 0 && count < PRACTICE_CARD_SIZE) {
              const qData = candidates[category].shift();
              currentPracticeCardQuestions.push(qData);
              // If an unseen question is picked, immediately mark it as new-learning
              if (category === 'unseen') {
                  performanceData[qData.qNum].category = 'new-learning';
              }
              count++;
              needed--;
          }
      }

      // 2. Add Mastered questions that need resurfacing
      // Sort mastered by lastSeenInQuiz (ascending) to get older ones first
      const resurfaceCandidates = candidates.mastered
          .filter(qData => (quizCounter - performanceData[qData.qNum].lastSeenInQuiz) > minMasteredResurfaceInterval)
          .sort((a, b) => performanceData[a.qNum].lastSeenInQuiz - performanceData[b.qNum].lastSeenInQuiz);

      while (count < PRACTICE_CARD_SIZE && resurfaceCandidates.length > 0) {
          currentPracticeCardQuestions.push(resurfaceCandidates.shift());
          count++;
      }

      // 3. Fill any remaining slots with a general mix from remaining questions
      // Prioritize from harder categories first if still available
      let remainingQuestionsPool = [];
      // Re-add remaining questions from candidates in priority order to the pool
      for (const category of priorityOrder) {
          remainingQuestionsPool = remainingQuestionsPool.concat(candidates[category]);
      }
      // Add any remaining mastered questions that didn't meet the resurfacing criteria
      remainingQuestionsPool = remainingQuestionsPool.concat(candidates.mastered);

      remainingQuestionsPool.sort(() => 0.5 - Math.random()); // Shuffle the entire remaining pool

      while (count < PRACTICE_CARD_SIZE && remainingQuestionsPool.length > 0) {
          currentPracticeCardQuestions.push(remainingQuestionsPool.shift());
          count++;
      }

      // Final shuffle of the selected questions for randomness within the card
      currentPracticeCardQuestions.sort(() => 0.5 - Math.random());

      if (currentPracticeCardQuestions.length === 0) {
        showNotification(s.noQuestionsAvailableForPractice, 'info'); // Use a UI string for this
        return;
      }

      // Update lastSeenInQuiz for all questions in the generated practice card
      currentPracticeCardQuestions.forEach(qData => {
          performanceData[qData.qNum].lastSeenInQuiz = quizCounter;
      });
      savePerformanceData(); // Save quizCounter and updated lastSeenInQuiz

      renderPracticeCardQuestions(currentPracticeCardQuestions);
      document.getElementById('checkPracticeCardButton').style.display = 'block';
      document.getElementById('practiceCardScoreText').textContent = ''; // Clear previous score
      document.getElementById('generateNewPracticeCardButton').style.display = 'none'; // Hide until checked
    }

    // Renders the practice card questions directly on the page
    function renderPracticeCardQuestions(questionsToRender) {
      const displayArea = document.getElementById('practiceQuestionsDisplayArea');
      displayArea.innerHTML = ''; // Clear previous questions

      questionsToRender.forEach((qData, index) => {
        // Use 'pq' prefix for practice questions to avoid name conflicts with 'q' from test mode
        displayArea.appendChild(createQuestionElement(qData, 'pq', index + 1));
      });
    }

    // This function is now primarily for displaying the overall score of the practice card
    // Individual question updates are handled by processSingleQuestionAnswer
    function checkPracticeCardAnswers() {
      const s = uiStrings[currentLanguage];
      let score = 0;
      let answeredCount = 0;

      currentPracticeCardQuestions.forEach(qData => {
        const radios = document.getElementsByName(`pq${qData.qNum}`);
        let selectedVal = null;
        radios.forEach(rb => { if (rb.checked) selectedVal = rb.value; });

        if (selectedVal !== null) {
          answeredCount++;
          // Check if the last attempt for this question was correct based on performanceData
          const questionPerf = performanceData[qData.qNum];
          if (questionPerf && questionPerf.history.length > 0 && questionPerf.history[questionPerf.history.length - 1].correct) {
              score++;
          }
        }
      });

      if (answeredCount === currentPracticeCardQuestions.length) {
          document.getElementById('practiceCardScoreText').textContent = `${s.scoreForPageLabel}: ${score} / ${currentPracticeCardQuestions.length}`;
          document.getElementById('generateNewPracticeCardButton').style.display = 'block'; // Show new card button
      } else {
          // Optionally, show a message if not all questions are answered
          showNotification("Veuillez répondre à toutes les questions avant de vérifier.", 'info');
      }

      // No need to call savePerformanceData here as it's called by processSingleQuestionAnswer
    }

    // --- Performance Stats Modal Functions ---
    function showPerformanceStatsModal() {
      const s = uiStrings[currentLanguage];
      const body = document.getElementById('performanceStatsBody');
      body.innerHTML = '';

      const stats = {
        unseen: [], 'new-learning': [], 'learning-bad': [], 'learning-normal': [], 'learning-good': [], mastered: [], problematic: [],
        totalCorrect: 0, totalIncorrect: 0
      };

      allQuizData.forEach(qData => {
        const perf = performanceData[qData.qNum];
        if (perf) {
          stats[perf.category].push(qData);
          stats.totalCorrect += perf.correctAttempts;
          stats.totalIncorrect += perf.incorrectAttempts;
        } else {
          stats.unseen.push(qData); // Should not happen if loadPerformanceData is correct
        }
      });

      const categoryLabels = {
          unseen: s.categoryUnseen,
          'new-learning': s.categoryNewLearning,
          // 'learning-bad': s.categoryLearningBad, // Hidden
          'learning-normal': s.categoryLearningNormal,
          // 'learning-good': s.categoryLearningGood, // Hidden
          mastered: s.categoryMastered,
          problematic: s.categoryProblematic
      };

      // Order for display in stats modal (from most difficult to easiest)
      // Exclude 'learning-bad' and 'learning-good' from explicit display
      const displayOrder = ['problematic', 'learning-normal', 'new-learning', 'unseen', 'mastered'];

      displayOrder.forEach(category => {
        // Only display if the category is not 'learning-bad' or 'learning-good'
        if (category !== 'learning-bad' && category !== 'learning-good') {
            const detailEl = document.createElement('details');
            detailEl.className = 'category-detail';
            const summaryEl = document.createElement('summary');
            summaryEl.textContent = `${categoryLabels[category]}: ${stats[category].length} ${s.questionsInCategory}`;
            detailEl.appendChild(summaryEl);

            const ulEl = document.createElement('ul');
            if (stats[category].length > 0) {
                // Sort questions by qNum for consistent display within categories
                stats[category].sort((a, b) => a.qNum - b.qNum).forEach(qData => {
                    const liEl = document.createElement('li');
                    liEl.textContent = `Q${qData.qNum}: ${qData.text[currentLanguage].substring(0, 100)}...`; // Show first 100 chars
                    ulEl.appendChild(liEl);
                });
            } else {
                const liEl = document.createElement('li');
                liEl.textContent = "Aucune question dans cette catégorie.";
                ulEl.appendChild(liEl);
            }
            detailEl.appendChild(ulEl);
            body.appendChild(detailEl);
        }
      });


      const divider = document.createElement('hr');
      divider.className = 'my-2';
      body.appendChild(divider);

      const pCorrect = document.createElement('p');
      pCorrect.className = 'text-green-700 font-semibold';
      pCorrect.textContent = `${s.totalCorrect}: ${stats.totalCorrect}`;
      body.appendChild(pCorrect);

      const pIncorrect = document.createElement('p');
      pIncorrect.className = 'text-red-700 font-semibold';
      pIncorrect.textContent = `${s.totalIncorrect}: ${stats.totalIncorrect}`;
      body.appendChild(pIncorrect);

      document.getElementById('performanceStatsModal').style.display = 'block';
    }

    function closePerformanceStatsModal() {
      document.getElementById('performanceStatsModal').style.display = 'none';
    }

    // ––– END OF NEW PERFORMANCE TRACKING AND PRACTICE CARD LOGIC –––

    window.onclick = function (event) {
      if (event.target == document.getElementById('finalResultsModal')) {
        closeFinalResultsModal();
      }
      if (event.target == document.getElementById('performanceStatsModal')) {
        closePerformanceStatsModal();
      }
      // Close custom confirmation modal if clicked outside
      if (event.target == document.getElementById('customConfirmationModal')) {
          closeConfirmationModal();
      }
    };
  </script>

  <div class="text-center text-gray-500 text-xs mt-8 pb-4">
    Version <span id="appVersion">1.0.2</span>
  </div>
</body>
</html>
